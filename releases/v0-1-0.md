# 🚀 Luma v0.1.0 — Ownership and Static Analysis Update

Luma is a modern, low-level compiled language focused on **manual memory management with compile-time safety**.

This release introduces **ownership annotations**, **pointer aliasing tracking**, and significant improvements to the **static analyzer**.  
It's now capable of verifying most memory operations — before codegen — while keeping full manual control in the developer's hands.

---

## ✨ Highlights

### 🧠 Static Memory Analyzer
Luma's static analyzer now validates heap operations at compile time:
- Detects **use-after-free**, **double-free**, and **memory leaks**
- Integrates with `defer` for automatic cleanup
- Tracks **ownership transfers** between variables
- Performs analysis at the end of type checking (no runtime cost)
- Reports exact source locations for memory safety issues

**Example:**
```lux
let p = alloc(32);
free(p);
use(p); // ❌ use-after-free (caught at compile time)
```

### 🔗 Pointer Aliasing Support

Ownership and lifetime tracking now correctly handle pointer aliasing:

```lux
let c: *char = cast<*char>(alloc(6 * sizeof<char>));
let b: *char = c;
defer { free(b); }
```

The analyzer recognizes `b` as an alias of `c` and ensures they share the same ownership record.
- ✅ No double-free
- ✅ No leaks
- ✅ Clean valgrind output

### 🏷️ Ownership Annotations

Added two new annotations to help the analyzer understand memory semantics:

| Annotation | Description |
|------------|-------------|
| `#returns_ownership` | Marks functions that return owned memory |
| `#takes_ownership` | Marks parameters that consume ownership of their arguments |

**Example:**

```lux
#returns_ownership
pub const make_buffer = fn(size: int) *char {
    return alloc(size);
}

#takes_ownership
pub const consume = fn(ptr: *char) void {
    free(ptr);
}
```

These annotations make ownership intent explicit while avoiding a full borrow/lifetime system.

### 🧩 Developer Experience

- `alloc()`, `free()`, and `defer` now integrate directly with the analyzer
- Improved diagnostic clarity (better source mapping and context)
- Consistent behavior across alias chains
- Simplified and cleaner syntax for low-level constructs

---

## 🔮 Next Steps

- Cross-function memory tracking
- Struct and array allocation tracking
- Codegen for struct (functions) and union
- Generics and type inference

---

## 🧠 Philosophy

Luma's goal is to stay low-level and explicit — no garbage collector, no runtime lifetimes —
just pure manual memory control with a static verifier ensuring it's safe.

> "You choose when to free — Luma just makes sure you do it right."

---

## 🧪 Verified Behavior

- ✅ All test cases pass under Valgrind (no leaks)
- ✅ Analyzer successfully detects invalid frees and missing frees
- ✅ Pointer aliasing merges ownership safely
- ✅ Deferred frees resolve correctly across scopes

---

## 📦 Example
For examples look at the test folder [here](../tests/) or the std folder here [here](../std/).

---

Made with ❤️ by Connor Harris  
🔗 GitHub: [TheDevConnor/Luma](https://github.com/TheDevConnor/Luma)

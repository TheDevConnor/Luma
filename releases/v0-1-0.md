# ğŸš€ Luma v0.1.0 â€” Ownership and Static Analysis Update

Luma is a modern, low-level compiled language focused on **manual memory management with compile-time safety**.

This release introduces **ownership annotations**, **pointer aliasing tracking**, and significant improvements to the **static analyzer**.  
It's now capable of verifying most memory operations â€” before codegen â€” while keeping full manual control in the developer's hands.

---

## âœ¨ Highlights

### ğŸ§  Static Memory Analyzer
Luma's static analyzer now validates heap operations at compile time:
- Detects **use-after-free**, **double-free**, and **memory leaks**
- Integrates with `defer` for automatic cleanup
- Tracks **ownership transfers** between variables
- Performs analysis at the end of type checking (no runtime cost)
- Reports exact source locations for memory safety issues

**Example:**
```lux
let p = alloc(32);
free(p);
use(p); // âŒ use-after-free (caught at compile time)
```

### ğŸ”— Pointer Aliasing Support

Ownership and lifetime tracking now correctly handle pointer aliasing:

```lux
let c: *char = cast<*char>(alloc(6 * sizeof<char>));
let b: *char = c;
defer { free(b); }
```

The analyzer recognizes `b` as an alias of `c` and ensures they share the same ownership record.
- âœ… No double-free
- âœ… No leaks
- âœ… Clean valgrind output

### ğŸ·ï¸ Ownership Annotations

Added two new annotations to help the analyzer understand memory semantics:

| Annotation | Description |
|------------|-------------|
| `#returns_ownership` | Marks functions that return owned memory |
| `#takes_ownership` | Marks parameters that consume ownership of their arguments |

**Example:**

```lux
#returns_ownership
pub const make_buffer = fn(size: int) *char {
    return alloc(size);
}

#takes_ownership
pub const consume = fn(ptr: *char) void {
    free(ptr);
}
```

These annotations make ownership intent explicit while avoiding a full borrow/lifetime system.

### ğŸ§© Developer Experience

- `alloc()`, `free()`, and `defer` now integrate directly with the analyzer
- Improved diagnostic clarity (better source mapping and context)
- Consistent behavior across alias chains
- Simplified and cleaner syntax for low-level constructs

---

## ğŸ”® Next Steps

- Cross-function memory tracking
- Struct and array allocation tracking
- Codegen for struct (functions) and union
- Generics and type inference

---

## ğŸ§  Philosophy

Luma's goal is to stay low-level and explicit â€” no garbage collector, no runtime lifetimes â€”
just pure manual memory control with a static verifier ensuring it's safe.

> "You choose when to free â€” Luma just makes sure you do it right."

---

## ğŸ§ª Verified Behavior

- âœ… All test cases pass under Valgrind (no leaks)
- âœ… Analyzer successfully detects invalid frees and missing frees
- âœ… Pointer aliasing merges ownership safely
- âœ… Deferred frees resolve correctly across scopes

---

## ğŸ“¦ Example
For examples look at the test folder [here](../tests/) or the std folder here [here](../std/).

---

Made with â¤ï¸ by Connor Harris  
ğŸ”— GitHub: [TheDevConnor/Luma](https://github.com/TheDevConnor/Luma)

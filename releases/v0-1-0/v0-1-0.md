# Luma v0.1.0 - Initial Release

We're excited to announce the first public release of **Luma**, a statically typed, compiled systems programming language designed for simplicity, safety, and performance.

## What is Luma?

Luma combines the low-level control of C with modern safety features and a clean, consistent syntax. It's designed for systems programmers who want predictable performance without sacrificing code clarity or safety.

### Core Principles

- **Simplicity**: Minimal syntax with consistent patterns
- **Safety**: Strong typing and compile-time memory safety verification
- **Performance**: Zero-cost abstractions and predictable performance

### Key Features

- **Strong Static Type System** with explicit typing
- **Manual Memory Management** with compile-time static analysis
- **Struct Methods** for clean object-oriented patterns
- **Ownership Annotations** for clear memory semantics
- **Modern Safety Features** including defer statements and pointer aliasing tracking
- **Simple Module System** for code organization
- **Pattern Matching** via exhaustive switch statements
- **Direct System Calls** for low-level control

## What's New in v0.1.0

### Static Memory Analyzer

The compiler now validates heap operations at compile time:
- Detects **use-after-free**, **double-free**, and **memory leaks**
- Integrates with `defer` for automatic cleanup tracking
- Tracks **ownership transfers** between variables
- Performs analysis at the end of type checking (no runtime cost)
- Reports exact source locations for memory safety issues

**Example:**
```luma
let p = alloc(32);
free(p);
use(p); // Error: use-after-free (caught at compile time)
```

### Pointer Aliasing Support

Ownership and lifetime tracking now correctly handle pointer aliasing:

```luma
let c: *char = cast<*char>(alloc(6 * sizeof<char>));
let b: *char = c;
defer { free(b); }
```

The analyzer recognizes `b` as an alias of `c` and ensures they share the same ownership record, preventing double-free errors and memory leaks.

### Ownership Annotations

Two new function attributes help the analyzer understand memory semantics:

**`#returns_ownership`** - Marks functions that return owned memory:

```luma
#returns_ownership
pub const make_buffer -> fn(size: int) *char {
    return alloc(size);
}
```

**`#takes_ownership`** - Marks parameters that consume ownership:

```luma
#takes_ownership
pub const consume -> fn(ptr: *char) void {
    free(ptr);
}
```

These annotations make ownership intent explicit while avoiding a full borrow/lifetime system.

## What's Included

### Language Features

- Complete type system (primitives, structs, enums, arrays, pointers)
- Struct methods
- Pattern matching with switch statements
- Defer statements for resource cleanup
- Static memory analysis (leak detection, double-free prevention)
- Ownership attributes (`#returns_ownership`, `#takes_ownership`)
- Module system with `@use` and `@module`

### Standard Library

The v0.1.0 release includes several essential modules:

- **`math`** - Mathematical operations, trigonometry, constants
- **`memory`** - Low-level memory operations (memcpy, memset, calloc, etc.)
- **`string`** - String manipulation and conversion functions
- **`sys`** - Linux system call wrappers (x86_64 only)
- **`terminal`** - Interactive terminal input (getch, getpass, etc.)
- **`termfx`** - ANSI terminal formatting and colors
- **`time`** - Timing and sleep functions
- **`io`** - Formatted I/O operations

### Example Programs

This release includes several fully working example programs:

1. **Chess Engine** - Complete chess implementation with move validation and check detection
2. **Tetris** - Full terminal-based Tetris game with colors and scoring
3. **3D Spinning Cube** - Real-time 3D rendering in the terminal
4. **Bubble Sort** - Classic sorting algorithm demonstration
5. **Test Suites** - Comprehensive tests for memory, string, and system operations

## Quick Start

```luma
@module "main"

@use "math" as math
@use "termfx" as fx

const Point -> struct {
    x: int,
    y: int
};

pub const main -> fn () int {
    let origin: Point = Point { x: 0, y: 0 };
    let destination: Point = Point { x: 3, y: 4 };
    
    let distance: double = math::sqrt(
        cast<double>((destination.x - origin.x) * (destination.x - origin.x) +
                     (destination.y - origin.y) * (destination.y - origin.y))
    );
    
    output(fx::GREEN, "Distance: ", fx::RESET, distance, "\n");
    return 0;
}
```

Compile and run:
```bash
luma main.lx -name program -l std/math.lx std/termfx.lx std/string.lx
./program
```

## Installation

### Pre-built Binaries

Download the latest release for your platform:
- [Linux x86_64](https://github.com/Luma-Programming-Language/Luma/releases/download/v0.1.0/luma-linux-x86_64)

### From Source

Requires: GCC/Clang, Make, LLVM

```bash
git clone https://github.com/Luma-Programming-Language/Luma.git
cd luma
make
sudo ./install.sh
```

## Platform Support

**Current Release:**
- Linux x86_64

**Planned:**
- macOS (ARM64 and x86_64)
- Windows
- Linux ARM64

The system call interface (`sys.lx`) is currently Linux-specific. Other modules are platform-agnostic.

## Known Limitations

This is an early release. Please be aware of these current limitations:

### Language
- No generics yet (planned for future release)
- No function overloading
- Limited operator overloading
- No compile-time evaluation beyond constants
- No module exports beyond `pub` keyword

### Standard Library
- `sys.lx` is Linux x86_64 only
- `terminal.lx` uses shell commands (may not work in all environments)
- Limited string formatting capabilities
- No networking or file I/O abstractions (use `sys` module directly)

### Tooling
- No package manager yet
- Limited error messages
- No LSP or IDE support
- Manual compilation only (no build system beyond makefiles)

### Known Bugs
- Pipe operations in `sys.lx` may block indefinitely (marked in tests)
- Some terminal operations might not work on all terminal emulators
- Memory analyzer may have false positives with complex ownership patterns

## Example Programs

Try these example programs to see Luma in action:

```bash
# Terminal Tetris
luma tetris.lx -name tetris -l std/string.lx std/terminal.lx std/termfx.lx std/math.lx std/time.lx && ./tetris

# 3D Spinning Cube
luma 3d_spinning_cube.lx -name cube -l std/math.lx std/memory.lx std/string.lx std/termfx.lx std/time.lx std/io.lx && ./cube

# Memory Tests (with Valgrind)
luma mem_test.lx -name mem_test -l std/memory.lx && valgrind --leak-check=full ./mem_test

# Chess Game
luma main.lx -l board.lx piece.lx std/terminal.lx std/string.lx std/termfx.lx std/memory.lx -name chess && ./chess
```

## Documentation

Complete language documentation is included in `docs.md`, covering:
- Language philosophy and design
- Complete type system reference
- Memory management guide
- Standard library API reference
- Example programs and patterns

## Verified Behavior

- All test cases pass under Valgrind (no leaks)
- Analyzer successfully detects invalid frees and missing frees
- Pointer aliasing merges ownership safely
- Deferred frees resolve correctly across scopes

## Roadmap

Future releases will focus on:

1. **v0.2.0** - Cross-platform support (macOS)
2. **v0.3.0** - Package manager and build system
3. **v0.4.0** - Language Server Protocol (LSP) support
4. **v0.5.0** - Advanced features (traits, interfaces, compile-time functions)

## Contributing

We welcome contributions! This is an early-stage project and there's plenty to do:

- Report bugs via GitHub Issues
- Suggest features via GitHub Discussions
- Improve documentation
- Add test cases
- Fix known issues
- Create standard library modules

Please see `CONTRIBUTING.md` for guidelines.

## Philosophy

Luma's goal is to stay low-level and explicit - no garbage collector, no runtime lifetimes - just pure manual memory control with a static verifier ensuring it's safe.

> "You choose when to free - Luma just makes sure you do it right."

## License

Luma is released under the MIT License. 

## Acknowledgments

Thank you to everyone who provided feedback during development and to the systems programming community for inspiration from languages like C, Rust, and Zig.

## Getting Help

- **Documentation**: See `docs.md` in the repository
- **Issues**: https://github.com/Luma-Programming-Language/Luma/issues
- **Discussions**: https://github.com/Luma-Programming-Language/Luma/discussions
- **Examples**: Check the `tests/` and `examples/` directories

---

**Note**: This is an alpha-quality release intended for experimentation and feedback. It is **not recommended for production use** at this time. APIs may change between releases.

We're excited to share Luma with the community and look forward to your feedback!

---

Made with care by the Luma Team  
GitHub: [Luma-Programming-Language/Luma](https://github.com/Luma-Programming-Language/Luma)

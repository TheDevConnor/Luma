@module "parser"

@use "lexer" as lexer
@use "ast" as ast
@use "sys" as sys

const BindingPower -> enum {
  BP_NONE,        /**< No binding power */
  BP_LOWEST,      /**< Lowest binding power */
  BP_ASSIGN,      /**< Assignment operators (=, +=, etc.) */
  BP_TERNARY,     /**< Ternary conditional operator (? :) */
  BP_LOGICAL_OR,  /**< Logical OR operator (||) */
  BP_LOGICAL_AND, /**< Logical AND operator (&&) */
  BP_BITWISE_OR,  /**< Bitwise OR operator (|) */
  BP_BITWISE_XOR, /**< Bitwise XOR operator (^) */
  BP_BITWISE_AND, /**< Bitwise AND operator (&) */
  BP_EQUALITY,    /**< Equality operators (==, !=) */
  BP_RELATIONAL,  /**< Relational operators (<, >, <=, >=) */
  BP_RANGE,       /**< Range operations (..) */
  BP_SHIFT,       /**< Shift operators (<<, >>) */
  BP_SUM,         /**< Addition and subtraction (+, -) */
  BP_PRODUCT,     /**< Multiplication, division, modulo (*, /, %) */
  BP_EXPONENT,    /**< Exponentiation operator (**) */
  BP_UNARY,       /**< Unary operators (!, ~, +, -, prefix ++/--) */
  BP_POSTFIX,     /**< Postfix operators (++/-- postfix) */
  BP_CALL,        /**< Function call or indexing */
  BP_PRIMARY      /**< Primary expressions (literals, variables) */
};

pub const Parser -> struct {
  tks: *Token,
  path: *char,
  pos: int,
};

pub const init_parser -> fn (psr: *Parser, tks: *Token, path: *char) void {
  psr.path = path;
  psr.tks = tks;
  psr.pos = 0;
}

pub const peek -> fn (psr: *Parser, index: int) Token {
  return psr.tks.list[index];
}

pub const parse -> fn (tks: *Token, path: *char) *ASTNode {
  let psr: Parser;
  init_parser(&psr, tks, path);

  sys::print(peek(&psr, 10).value);

  return cast<*ASTNode>(0); 
}

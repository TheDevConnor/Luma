@module "parser"

@use "string" as string
@use "lexer" as lexer
@use "ast" as ast
@use "sys" as sys

const BindingPower -> enum {
  BP_NONE,        /**< No binding power */
  BP_LOWEST,      /**< Lowest binding power */
  BP_ASSIGN,      /**< Assignment operators (=, +=, etc.) */
  BP_TERNARY,     /**< Ternary conditional operator (? :) */
  BP_LOGICAL_OR,  /**< Logical OR operator (||) */
  BP_LOGICAL_AND, /**< Logical AND operator (&&) */
  BP_BITWISE_OR,  /**< Bitwise OR operator (|) */
  BP_BITWISE_XOR, /**< Bitwise XOR operator (^) */
  BP_BITWISE_AND, /**< Bitwise AND operator (&) */
  BP_EQUALITY,    /**< Equality operators (==, !=) */
  BP_RELATIONAL,  /**< Relational operators (<, >, <=, >=) */
  BP_RANGE,       /**< Range operations (..) */
  BP_SHIFT,       /**< Shift operators (<<, >>) */
  BP_SUM,         /**< Addition and subtraction (+, -) */
  BP_PRODUCT,     /**< Multiplication, division, modulo (*, /, %) */
  BP_EXPONENT,    /**< Exponentiation operator (**) */
  BP_UNARY,       /**< Unary operators (!, ~, +, -, prefix ++/--) */
  BP_POSTFIX,     /**< Postfix operators (++/-- postfix) */
  BP_CALL,        /**< Function call or indexing */
  BP_PRIMARY      /**< Primary expressions (literals, variables) */
};

pub const Parser -> struct {
  tks: *Token,
  path: *char,
  pos: int,

  init_parser -> fn (tks: *Token, path: *char) void {
    self.path = path;
    self.tks = tks;
    self.pos = 0;
  },
};

// TODO: Add in resolution types for namespaces/modules ex: *Expr, ast::NodeType,
// TODO: and fix the types for the module system for enums and structs with it.

const at_end  -> fn (psr: *Parser) int { return cast<int>(psr.pos >= psr.tks.size); }
const peek    -> fn (psr: *Parser) Token {  return psr.tks.list[psr.pos]; }
const advance -> fn (psr: *Parser) void { psr.pos = psr.pos + 1; }

const parse_expr -> fn (psr: *Parser, bp: int) *Expr;

const get_infix_bp -> fn (token_type: int) int {
  switch (token_type) {
    16, 17 -> return BindingPower::BP_SUM;    
    18, 19 -> return BindingPower::BP_PRODUCT;
    _ -> return BindingPower::BP_NONE;
  }
}

const parse_literal -> fn (psr: *Parser) *Expr {
  let tok: Token = peek(psr);
  
  switch (tok.type) {
    0 -> { //number
      let value: int = string::atio(tok.value);
      advance(psr);
      return ast::create_number_node(value);
    }
    1 -> { //ident
      let name: *char = tok.value;
      advance(psr);
      return ast::create_ident_node(name);
    }
    2 -> { //string
      let value: *char = tok.value;
      advance(psr);
      return ast::create_string_node(value);
    }
    _ -> {
      output("Unexpected token in literal parsing\n");
      return cast<*Expr>(0);
    }
  }
}

const nud -> fn (psr: *Parser) *Expr {
  let tok: Token = peek(psr);
  
  switch (tok.type) {
    0, 1, 2 -> { return parse_literal(psr); } //number, ident, string
    6 -> { //(
      advance(psr);
      let expr: *Expr = parse_expr(psr, BindingPower::BP_NONE);
      let next_tok: Token = peek(psr);
      if (next_tok.type != 7) { //)
        output("Expected closing parenthesis\n");
        return cast<*Expr>(0);
      }
      advance(psr); //consume )
      return ast::create_group_node(expr);
    }
    16, 17 -> { //+, -
      let op: *char = tok.value;
      advance(psr);
      let right: *Expr = parse_expr(psr, BindingPower::BP_UNARY);
      return ast::create_unary_node(op[0], right);
    }
    _ -> {
      output("Unexpected token in prefix position\n");
      return cast<*Expr>(0);
    }
  }
}

const led -> fn (psr: *Parser, left: *Expr, token: Token) *Expr {
  switch (token.type) {
    12, 13, 16, 17, 18, 19 -> { //==, !=, +, -, *, / 
      let op: *char = psr.tks.list[psr.pos].value; 
      advance(psr);
      let right: *Expr = parse_expr(psr, get_infix_bp(token.type));
      return ast::create_binary_node(op[0], left, right);
    }
    _ -> {
      output("Unexpected token in infix position\n");
      return cast<*Expr>(0);
    }
  }
}

const parse_expr -> fn (psr: *Parser, bp: int) *Expr {
  let left: *Expr = nud(psr);
  
  // Inline the led logic here
  loop (at_end(psr) == 0 && bp < get_infix_bp(peek(psr).type)) {
    let tok: Token = peek(psr);
    let next_bp: int = get_infix_bp(tok.type);
    
    left = led(psr, left, tok);
  }
  
  return left;
}

pub const parse -> fn (tks: *Token, path: *char) *Stmt {
  let psr: Parser;
  psr.init_parser(tks, path);
  
  let node: *Expr = parse_expr(&psr, BindingPower::BP_NONE);
  
  return ast::create_program_node(node, tks.size); 
}

@module "parser"

@use "lexer" as lexer
@use "ast" as ast
@use "sys" as sys

const BindingPower -> enum {
  BP_NONE,        /**< No binding power */
  BP_LOWEST,      /**< Lowest binding power */
  BP_ASSIGN,      /**< Assignment operators (=, +=, etc.) */
  BP_TERNARY,     /**< Ternary conditional operator (? :) */
  BP_LOGICAL_OR,  /**< Logical OR operator (||) */
  BP_LOGICAL_AND, /**< Logical AND operator (&&) */
  BP_BITWISE_OR,  /**< Bitwise OR operator (|) */
  BP_BITWISE_XOR, /**< Bitwise XOR operator (^) */
  BP_BITWISE_AND, /**< Bitwise AND operator (&) */
  BP_EQUALITY,    /**< Equality operators (==, !=) */
  BP_RELATIONAL,  /**< Relational operators (<, >, <=, >=) */
  BP_RANGE,       /**< Range operations (..) */
  BP_SHIFT,       /**< Shift operators (<<, >>) */
  BP_SUM,         /**< Addition and subtraction (+, -) */
  BP_PRODUCT,     /**< Multiplication, division, modulo (*, /, %) */
  BP_EXPONENT,    /**< Exponentiation operator (**) */
  BP_UNARY,       /**< Unary operators (!, ~, +, -, prefix ++/--) */
  BP_POSTFIX,     /**< Postfix operators (++/-- postfix) */
  BP_CALL,        /**< Function call or indexing */
  BP_PRIMARY      /**< Primary expressions (literals, variables) */
};

pub const Parser -> struct {
  tks: *Token,
  path: *char,
  pos: int,

  init_parser -> fn (tks: *Token, path: *char) void {
    self.path = path;
    self.tks = tks;
    self.pos = 0;
  },
};

const peek -> fn (psr: *Parser) Token { 
  return psr.tks.list[psr.pos]; 
}

const advance -> fn (psr: *Parser) void {
  psr.pos = psr.pos + 1;
}

const at_end -> fn (psr: *Parser) int {
  if (psr.pos >= psr.tks.size) {
    return 1;
  }
  return 0;
}

const parse_int -> fn (value: *char) int {
  let num: int = 0;
  loop [i: int = 0](value[i] != '\0') : (++i) { 
    if (cast<int>(value[i]) >= 48 && cast<int>(value[i]) <= 57) { 
      num = num * 10 + (cast<int>(value[i]) - 48); 
    } else { 
      break; 
    }
  }
  return num;
}

const get_infix_bp -> fn (token_type: int) int {
  switch (token_type) {
    16, 17 -> return BindingPower::BP_SUM;    
    18, 19 -> return BindingPower::BP_PRODUCT;
    _ -> return BindingPower::BP_NONE;
  }
}

const nud -> fn (psr: *Parser) *Expr {
  let tok: Token = peek(psr);
  
  switch (tok.type) {
    0 -> {  // Number literal
      let num: int = parse_int(tok.value);
      advance(psr);
      return ast::create_number_node(num);
    }
    _ -> {
      output("Unexpected token in prefix position\n");
      return cast<*Expr>(0);
    }
  }
}

const parse_expr -> fn (psr: *Parser, bp: int) *Expr {
  let left: *Expr = nud(psr);
  
  // Inline the led logic here
  loop (at_end(psr) == 0 && bp < get_infix_bp(peek(psr).type)) {
    let tok: Token = peek(psr);
    let next_bp: int = get_infix_bp(tok.type);
    
    switch (tok.type) {
      16, 17, 18, 19 -> { // +, -, *, / 
        let op: *char = psr.tks.list[psr.pos].value; 
        advance(psr);
        let right: *Expr = parse_expr(psr, next_bp);
        left = ast::create_binary_node(op[0], left, right);
      }
      _ -> { }  // Do nothing, exit loop
    }
  }
  
  return left;
}

pub const parse -> fn (tks: *Token, path: *char) *Stmt {
  let psr: Parser;
  psr.init_parser(tks, path);
  
  let node: *Expr = parse_expr(&psr, BindingPower::BP_NONE);
  
  return ast::create_program_node(node); 
}

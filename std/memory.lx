@module "memory"

pub const memcpy = fn (dest: *void, src: *void, n: int) *void {
    let d: *char = cast<*char>(dest);
    let s: *char = cast<*char>(src);

    loop [i: int = 0](i < n) : (++i) {
        d[i] = s[i];
    }

    return dest;
}

pub const memcmp = fn (a: *void, b: *void, n: int) int {
    let x: *char = cast<*char>(a);
    let y: *char = cast<*char>(b);
    loop [i: int = 0](i < n) : (++i) {
        if (x[i] != y[i]) {
            return cast<int>(x[i]) - cast<int>(y[i]);
        }
    }
    return 0;
}

pub const memset = fn (dest: *void, value: int, n: int) *void {
    let d: *char = cast<*char>(dest);
    let c:  char = cast<char>(value);
    let i:   int = 0;

    loop (i + 4 <= n) : (i = i + 4) {
        d[i] = c;
        d[i+1] = c;
        d[i+2] = c;
        d[i+3] = c;
    }

    loop (i < n) : (++i) { d[i] = c; }

    return dest;
}

// Move memory regions (handles overlapping regions correctly)
pub const memmove = fn (dest: *void, src: *void, n: int) *void {
    let d: *char = cast<*char>(dest);
    let s: *char = cast<*char>(src);
    
    if (d < s) {
        // Copy forward
        loop [i: int = 0](i < n) : (++i) {
            d[i] = s[i];
        }
    } else {
        // Copy backward to handle overlap
        loop [i: int = n - 1](i >= 0) : (--i) {
            d[i] = s[i];
        }
    }
    
    return dest;
}

// Find first occurrence of byte in memory
pub const memchr = fn (ptr: *void, value: int, n: int) *void {
    let p: *char = cast<*char>(ptr);
    let target: char = cast<char>(value);
    
    loop [i: int = 0](i < n) : (++i) {
        if (p[i] == target) {
            return cast<*void>(cast<int>(p) + i);
        }
    }
    
    return cast<*void>(0); // NULL
}

// Zero out memory (common operation)
pub const memzero = fn (dest: *void, n: int) *void { return memset(dest, 0, n); }

// Allocate and zero memory (calloc equivalent)
#returns_ownership
pub const calloc = fn (count: int, size: int) *void {
    let total_size: int = count * size;
    let ptr: *void = alloc(total_size);
 
    if (ptr != cast<*void>(0)) {
        memzero(ptr, total_size);
    }
 
    return ptr;
}

// Reallocate memory (simplified version - allocates new and copies)
#returns_ownership 
pub const realloc = fn (ptr: *void, new_size: int) *void {
    if (ptr == cast<*void>(0)) {
        return alloc(new_size);
    }
 
    let new_ptr: *void = alloc(new_size);
    memcpy(new_ptr, ptr, new_size);
    free(ptr);
 
    return new_ptr;
}

// Memory swap (swap contents of two memory regions)
pub const memswap = fn (a: *void, b: *void, n: int) void {
    let p1: *char = cast<*char>(a);
    let p2: *char = cast<*char>(b);
    
    loop [i: int = 0](i < n) : (++i) {
        let temp: char = p1[i];
        p1[i] = p2[i];
        p2[i] = temp;
    }
}

pub const memswapn = fn (a: *void, b: *void, count: int, size: int) void {
    let temp: *void = alloc(size);

    loop [i: int = 0](i < count) : (++i) {
        let p1: *void = cast<*void>(cast<int>(a) + i * size);
        let p2: *void = cast<*void>(cast<int>(b) + i * size);
        
        memcpy(temp, p1, size);
        memcpy(p1, p2, size);
        memcpy(p2, temp, size);
    }

    free(temp);
}

pub const memfill = fn (dest: *void, value: int, size: int, count: int) *void {
    if (size == 1) {
        // Fill char/byte
        let d: *char = cast<*char>(dest);
        let byte_val: char = cast<char>(value);
        loop [i: int = 0](i < count) : (++i) {
            d[i] = byte_val;
        }
    } elif (size == 8) {
        // Fill int (8 bytes)
        let d: *int = cast<*int>(dest);
        loop [i: int = 0](i < count) : (++i) {
            d[i] = value;
        }
    } else {
        // For other sizes, just treat as bytes and fill with low byte of value
        let d: *char = cast<*char>(dest);
        let byte_val: char = cast<char>(value);
        let total: int = count * size;
        loop [i: int = 0](i < total) : (++i) {
            d[i] = byte_val;
        }
    }
    
    return dest;
}

// Reverse bytes in memory region
pub const memrev = fn (ptr: *void, n: int) *void {
    let p: *char = cast<*char>(ptr);
    let start: int = 0;
    let end: int = n - 1;
    
    loop (start < end) : (++start) {
        let temp: char = p[start];
        p[start] = p[end];
        p[end] = temp;
        --end;
    }
    
    return ptr;
}

// Count occurrences of a byte in memory
pub const memcount = fn (ptr: *void, value: int, n: int) int {
    let p: *char = cast<*char>(ptr);
    let target: char = cast<char>(value);
    let count: int = 0;
    
    loop [i: int = 0](i < n) : (++i) {
        if (p[i] == target) {
            ++count;
        }
    }
    
    return count;
}

// Duplicate memory region
#returns_ownership
pub const memdup = fn (src: *void, n: int) *void {
    let dest: *void = alloc(n);
    if (dest != cast<*void>(0)) {
        memcpy(dest, src, n);
    }
    return dest;
}

// Check if memory regions are equal
pub const memeq = fn (a: *void, b: *void, n: int) bool {
    return memcmp(a, b, n) == 0;
}

// Find substring in memory
pub const memmem = fn (haystack: *void, haystack_len: int, needle: *void, needle_len: int) *void {
    if (needle_len == 0) { return haystack; }
    if (needle_len > haystack_len) { return cast<*void>(0); }
    
    let h: *char = cast<*char>(haystack);
    let n: *char = cast<*char>(needle);
    let limit: int = haystack_len - needle_len;
    
    loop [i: int = 0](i <= limit) : (++i) {
        let found: int = 1;
        loop [j: int = 0](j < needle_len) : (++j) {
            if (h[i + j] != n[j]) {
                found = 0;
                break;
            }
        }
        if (found == 1) {
            return cast<*void>(cast<int>(h) + i);
        }
    }
    
    return cast<*void>(0);
}

pub const align = fn (member_alignments: *int, count: int) int {
    let max: int = 1;
    loop [i: int = 0](i < count) : (++i) {
        if (max < cast<*int>(member_alignments)[i]) {
            max = cast<*int>(member_alignments)[i];
        }
    }
    return max;
}

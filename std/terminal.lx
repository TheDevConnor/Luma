@module "terminal"

@use "string" as string
@use "termfx" as fx

// Global flag to track raw mode state
let raw_mode_enabled: int = 0;

// Enable raw mode - BLOCKING (waits for input)
pub const enable_raw_mode -> fn () void {
    if (raw_mode_enabled == 1) {
        return; // Already enabled
    }
   // nooo
    // Save terminal state and set up restoration on exit
    system("stty -g > /tmp/luma_termios_backup");
    
    // Configure raw mode:
    // -icanon: disable line buffering (read char by char)
    // -echo: don't echo input
    // -isig: disable interrupt signals (Ctrl+C, Ctrl+Z)
    // -ixon: disable software flow control (Ctrl+S, Ctrl+Q)
    // -icrnl: don't translate CR to NL
    // min 1 time 0: blocking read (wait for at least 1 character)
    system("stty -icanon -echo -isig -ixon -icrnl min 0 time 0");
    
    // Hide cursor
    output(fx::CURSOR_HIDE);
    
    raw_mode_enabled = 1;
}

// Disable raw mode - restore terminal to normal
pub const disable_raw_mode -> fn () void {
    if (raw_mode_enabled == 0) {
        return; // Already disabled
    }
    
    // Restore original terminal settings
    system("stty $(cat /tmp/luma_termios_backup)");
    system("rm /tmp/luma_termios_backup");
    
    // Show cursor
    output(fx::CURSOR_SHOW);
    
    // Reset colors
    output(fx::RESET);
    
    raw_mode_enabled = 0;
}

// Blocking input in raw mode - waits for a key but no Enter needed
// Use with enable_raw_mode() (not enable_raw_mode_nonblock)
pub const getch_raw -> fn () char {
    if (raw_mode_enabled == 0) {
        enable_raw_mode();
    }
    
    let c: char = input<char>("");
    return c;
}

// Get a single character without waiting for Enter
pub const getch -> fn () char {
    // Just try to read input; don't touch stty here
    let c: char = input<char>(""); 
    return c;
}

// Get a single character without waiting for Enter (no echo)
pub const getch_silent -> fn () char {
    // Already has -echo, so it won't display
    system("stty -icanon -echo");
    let c: char = input<char>("");
    system("stty icanon echo");
    return c;
}

#returns_ownership
pub const getche -> fn () char {
    // Disable canonical mode but keep echo
    system("stty -icanon echo");
    let c: char = input<char>("");
    system("stty icanon echo");
    return c;
}

// Check if a key is pressed (non-blocking)
// WARNING: This consumes the character! Don't use in raw mode.
pub const kbhit -> fn () int {
    // Non-blocking test only
    let result: int = system("read -t 0 -n 1 key < /dev/tty");
    if (result == cast<int>(0)) {
        // put the char back for getch()
        system("read -t 0 -n 1 key < /dev/tty && printf '%s' $key > /tmp/luma_kbhit_buf");
        return 1;
    }
    return 0;
}

// Wait for any key press
pub const wait_for_key -> fn () void {
    output("Press any key to continue...");
    getch();
    output("\n");
}

// Clear input buffer
pub const clear_input_buffer -> fn () void {
    system("stty -icanon -echo");
    
    // Read until no more input
    loop {
        system("stty min 0 time 0");
        let c: char = input<char>("");
        system("stty min 1 time 0");
        
        if (c == cast<char>(0)) {
            break;
        }
    }
    
    system("stty icanon echo");
}

// Get password input (hidden)
#returns_ownership
pub const getpass -> fn (prompt: *char) *char {
    output(prompt);
    
    // Allocate buffer for password
    let password: *char = cast<*char>(alloc(256));
    let i: int = 0;
    
    system("stty -icanon -echo");
    
    loop {
        let c: char = input<char>("");
        
        // Check for Enter key
        if (c == cast<char>(10) || c == cast<char>(13)) {
            break;
        }
        
        // Check for backspace
        if (c == cast<char>(127) || c == cast<char>(8)) {
            if (i > 0) {
                i = i - 1;
                output("\b \b"); // Erase character visually
            }
            continue;
        }
        
        password[i] = c;
        i = i + 1;
        output("*"); // Show asterisk for each character
    }
    
    password[i] = cast<char>(0); // Null terminate
    system("stty icanon echo");
    output("\n");
    
    return password;
}

// Sleep for milliseconds (more precise than system("sleep"))
pub const sleep_ms -> fn (ms: int) void {
    let cmd: *char = cast<*char>(alloc(64 * sizeof<char>));
    defer { free(cmd); }

    // Multiply milliseconds by 1000 for microseconds
    string::cat(cmd, "usleep ", string::from_int(ms * 1000));

    system(cmd);
}

// Get terminal size
pub const get_terminal_size -> fn () void {
    system("tput cols > /tmp/luma_cols");
    system("tput lines > /tmp/luma_lines");
    // Read back from files...
}

pub const get_line -> fn (prompt: *char, buffer: *char, size: int) void {
  output(prompt);
  let i: int = 0;
  loop (i < size - 1) : (++i) {
    let c: char = getch();
    if (c == '\n' || c == '\r') {
      break;
    }
    buffer[i] = c;
  }
  buffer[i] = '\0';
}

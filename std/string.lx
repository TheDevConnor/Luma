@module "string"

#returns_ownership 
pub const from_char -> fn (c: char) *char {
  let s: *char = cast<*char>(alloc(2 * sizeof<char>));
  s[0] = c;
  s[1] = cast<char>(0);
  return s;
}

#returns_ownership
pub const from_int -> fn (n: int) *char {
  if (n == 0) {
    return from_char(cast<char>('0'));
  }

  let negative: int = 0;
  if (n < 0) {
    negative = 1;
    n = -n;
  }

  let buffer: [char; 20]; // enough for 64-bit int
  let i: int = 0;

  loop (n != 0) {
    let digit: int = n % 10;
    buffer[i] = cast<char>(digit + cast<int>('0'));
    n = n / 10;
    i = i + 1;
  }

  if (negative == 1) {
    buffer[i] = '-';
    i = i + 1;
  }

  // Reverse the string
  let s: *char = cast<*char>(alloc((i + 1) * sizeof<char>));
  loop [j: int = 0](j < i) : (j = j + 1) {
    s[j] = buffer[i - j - 1];
  }
  s[i] = cast<char>(0); // null terminator

  return s;
}

pub const int_to_str -> fn (num: int, buf: *char, buf_size: int) void {
  let idx: int = 0;
  let temp: int = num;
  
  if (temp == 0) {
    buf[0] = '0';
    buf[1] = '\0';
    return;
  }
  
  loop (temp > 0 && idx < buf_size - 1) {
    buf[idx] = cast<char>((temp % 10) + 48);
    temp = temp / 10;
    idx = idx + 1;
  }
  
  // Reverse the digits
  let j: int = 0;
  loop (j < idx / 2) {
    let tmp: char = buf[j];
    buf[j] = buf[idx - 1 - j];
    buf[idx - 1 - j] = tmp;
    j = j + 1;
  }
  
  buf[idx] = '\0';
}

pub const strlen -> fn (s: *char) int {
  let length: int = 0;
  loop (s[length] != cast<char>(0)) : (++length) {}
  return length;
}

pub const strcmp -> fn (s1: *char, s2: *char) int {
  let ls1: int = strlen(s1);
  let ls2: int = strlen(s2);

  if (ls1 != ls2) { return -1; }

  loop[i: int = 0](i < ls1) : (++i) {
    if (s1[i] != s2[i]) { return 1; }
  }

  return 0;
}

pub const s_char -> fn (s: *char, c: int) char{
  loop [i: int = 0](s[i] != cast<char>(0)) : (++i) {
    if (s[i] == cast<char>(c)) {
      return s[i];
    }
  }

  return cast<char>(0);
}

pub const copy -> fn (dest: *char, src: *char) *char {
  let i: int = 0;
  loop((dest[i] = src[i]) != cast<char>(0)) : (++i) {}
  return dest;
}

pub const n_copy -> fn (dest: *char, src: *char, n: int) *char {
  let i: int = 0;
  loop(i < n && src[i] != cast<char>(0)) : (++i) {
    dest[i] = src[i]; 
  }
  return dest;
}

pub const cat -> fn (dest: *char, s1: *char, s2: *char) *char {
  let ls1: int = strlen(s1);
  let lt: int = ls1 + strlen(s2) + 1;

  loop [i: int = 0](i < lt) : (++i) {
    if (i < ls1) {
      dest[i] = s1[i];
    } else {
      dest[i] = s2[i - ls1];
    }
  }

  // null terminator
  dest[lt - 1] = cast<char>(0);

  return dest;
}

pub const putchar -> fn(c: char) int {
  // allocate buffer for command + escaped char (32 bytes is enough)
  let cmd: *char = cast<*char>(alloc(32 * sizeof<char>));
  defer { free(cmd); }

  // build command inline
  // Use integer values instead of character literals with escapes
  let char_val: int = cast<int>(c);
  
  switch(char_val) {
      10 -> { system("echo"); }                                        // '\n'
      9  -> { system("printf '\\t'"); }                                // '\t'
      37 -> cat(cmd, cast<*char>("printf '\\%'"),  cast<*char>(""));   // '%'
      92 -> cat(cmd, cast<*char>("printf '\\\\'"), cast<*char>(""));   // '\\'
      39 -> cat(cmd, cast<*char>("printf '\\\''"), cast<*char>(""));   // '\''
      34 -> cat(cmd, cast<*char>("printf '\\'"), cast<*char>(""));     // '"'
      36 -> cat(cmd, cast<*char>("printf '\\$'"),  cast<*char>(""));   // '$'
      96 -> cat(cmd, cast<*char>("printf '\\`'"),  cast<*char>(""));   // '`'
      _  -> {
          let s: *char = from_char(c);
          defer { free(s); }
          cat(cmd, cast<*char>("printf '%s' "), s);
      }
  }

  if (char_val != 10 && char_val != 9) { system(cmd); }
  
  return cast<int>(c);
}

pub const is_digit -> fn (ch: char) bool {
  return (ch >= '0' && ch <= '9');
}

pub const is_alpha -> fn (ch: char) bool {
  return ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch == '_' || ch == '@');
}

pub const is_alnum -> fn (ch: char) bool {
  return (is_alpha(ch) || is_digit(ch));
}

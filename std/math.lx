@module "math"
pub const PI: double = 3.14159265358979323;
pub const TWO_PI: double = 6.28318530717958647692528;

pub const DEPTH: int = 3;
pub const DT: double = 0.005525661; // 0.000034339 - 0.0055 - 0.00007;

pub const VALUES_COUNT: int = 127;
pub const VALUES: [double; 127] = [
     0.0000000000000000,  0.0499791692706783,  0.0998334166468282,  0.1494381324735992,
     0.1986693307950612,  0.2474039592545229,  0.2955202066613396,  0.3428978074554514,
     0.3894183423086505,  0.4349655341112302,  0.4794255386042030,  0.5226872289306592,
     0.5646424733950355,  0.6051864057360395,  0.6442176872376911,  0.6816387600233341,
     0.7173560908995228,  0.7512804051402927,  0.7833269096274834,  0.8134155047893737,
     0.8414709848078965,  0.8674232255940170,  0.8912073600614354,  0.9127639402605211,
     0.9320390859672264,  0.9489846193555862,  0.9635581854171930,  0.9757233578266591,
     0.9854497299884603,  0.9927129910375885,  0.9974949866040544,  0.9997837641893570,
     0.9995736030415051,  0.9968650284539189,  0.9916648104524686,  0.9839859468739369,
     0.9738476308781951,  0.9612752029752999,  0.9463000876874145,  0.9289597150038692,
     0.9092974268256817,  0.8873623686333753,  0.8632093666488737,  0.8368987907984977,
     0.8084964038195901,  0.7780731968879212,  0.7457052121767200,  0.7114733527908443,
     0.6754631805511506,  0.6377647021345036,  0.5984721441039564,  0.5576837173914166,
     0.5155013718214642,  0.4720305412898823,  0.4273798802338298,  0.3816609920523317,
     0.3349881501559047,  0.2874780123425444,  0.2392493292139820,  0.1904226473610270,
     0.1411200080598672,  0.0914646422324368,  0.0415806624332905, -0.0084072473671491,
    -0.0583741434275801, -0.1081951345301084, -0.1577456941432486, -0.2069019716733997,
    -0.2555411020268317, -0.3035415127084293, -0.3507832276896198, -0.3971481672859602,
    -0.4425204432948525, -0.4867866486556998, -0.5298361409084934, -0.5715613187423437,
    -0.6118578909427193, -0.6506251370651673, -0.6877661591839741, -0.7231881240865121,
    -0.7568024953079282, -0.7885252544261950, -0.8182771110644108, -0.8459837010754465,
    -0.8715757724135882, -0.8949893582285835, -0.9161659367494549, -0.9350525775584494,
    -0.9516020738895161, -0.9657730606206388, -0.9775301176650970, -0.9868438585032365,
    -0.9936910036334645, -0.9980544387588794, -0.9999232575641008, -0.9992927889753780,
    -0.9961646088358406, -0.9905465359667132, -0.9824526126243325, -0.9719030694018208,
    -0.9589242746631385, -0.9435486686359064, -0.9258146823277321, -0.9057666414687044,
    -0.8834546557201531, -0.8589344934265920, -0.8322674422239008, -0.8035201558521553,
    -0.7727644875559871, -0.7400773104888944, -0.7055403255703919, -0.6692398572762613,
    -0.6312666378723208, -0.5917155806310094, -0.5506855425976376, -0.5082790774992583,
    -0.4646021794137566, -0.4197640178398589, -0.3738766648302360, -0.3270548148697406,
    -0.2794154981989259, -0.2310777882993914, -0.1821625042720950, -0.1327919088525167,
    -0.0830894028174964, -0.0331792165475568,  0.0168139004843506
];

pub const add = fn (x: int, y: int) int {
    return x + y;
}

pub const subtract = fn (x: int, y: int) int {
    return x - y;
}

pub const multiply = fn (x: int, y: int) int {
    return x * y;
}

pub const divide = fn (x: int, y: int) int { 
    if (y == 0) {
        output("(Division by zero error) ");
        return 0;
    }
    return x / y;
}

pub const fib = fn (n: int, a: int, b: int) int {
    if (n == 0) { return a; }
    if (n == 1) { return b; }
    return fib(n - 1, b, a + b);
}

pub const power = fn (base: double, exponent: int) double {
    if (exponent == 0) { return 1.0; } 

    let result: double = 1.0;
    let e: int = exponent;

    if (e<0) {
        base = 1.0;
        e = -e;
    }

    loop (e > 0) : (--e) {
        result = result * base;
    }

    return result;
} 

pub const max_size = fn (a: int, b: int) int {
    if (a > b) { return a; }
    return b; 
}

pub const min_size = fn (a: int, b: int) int {
    if (a < b) { return a; }
    return b; 
}

// NOTE: Credit to 'Drake Rochelle' for the derivative, sin, cos, tan, sec, 
// csc, and cot algorithms
// https://github.com/Drake-Rochelle/
pub const sin = fn (x: double) double {
   let INV_TWO_PI: double = 1.0 / TWO_PI;
   let R: double = 1.0 / DT;
   x = x - TWO_PI * cast<int>(x * INV_TWO_PI);
   let scaled: double = x * R;
   let index: int = cast<int>(scaled);
   let t: double = scaled - index;
   return (VALUES[index] + t * (VALUES[index + 1] - VALUES[index]))*1.00016252;
}

// pub const asin = fn (x: double) double {
//     if (round(x) == x){
//         return x*0.78539816339744830961566084;
//     }
//     let abs_x: double = abs(x);
//     let sign: double = x/abs(x);
//     if (abs_x > 0.595){
//         let t2: double = 0.5 - 0.5 * abs_x;
//         let t: double = sqrt(t2);
//         let result: double = t * (1.0 + t2 * (0.16666666666666663 + t2 * (0.07500000000000001 + 
//                      t2 * (0.044642857142857144 + t2 * 0.030381944444444444))));
//         return sign * (1.5707963267948966 - 2.0 * result);
//     }
//     let x2: double = x * x;
//     return x * (1.0 + x2 * (0.16666666666666666 + x2 * (0.075 + 
//             x2 * (0.044642857142857144 + x2 * (0.03038194444444444 + 
//             x2 * (0.022372159090909092 + x2 * 0.017352764423076923))))));
// }

pub const cos = fn (x: double) double {
    return sin(x+(PI*0.5));
}

pub const tan = fn (x: double) double {
    return sin(x)/(cos(x)+0.000000001);
}

pub const sec = fn (x: double) double {
    return 1/(cos(x)+0.000000001);
}

pub const csc = fn (x: double) double {
    return 1/(sin(x)+0.000000001);
}

pub const cot = fn (x: double) double {
    return cos(x)/(sin(x)+0.000000001);
}

// const f = fn (x: double) double {
//     return math::sin(x); 
// }
// const d = fn (x: double) double {
//    return math::cos(x);
// }
// const derivative = fn (x: double) double {
//     let hp: **double = cast<**double>(alloc((DEPTH - 1) * sizeof<*double>));
//     defer { 
//       loop [c: int = 0](c < DEPTH - 1) : (++c) {
//         free(hp[c]);
//       }
//       free(hp); 
//     }
//     loop [c: int = 0](c < DEPTH - 1) : (++c) {
//       let size: int = DEPTH - c;
//       hp[c] = cast<*double>(alloc(size * sizeof<double>));
//     }
//     loop [c: int = 0, b: int = 0](c < DEPTH - 1) : (++c) {
//       let size: int = DEPTH - c;
//       loop (b < size) : (++b) {
//         if (c == 0) {                                                                    
//           hp[0][b] = f(x + (DT * b)) - ((f(x + (DT * b)) + f(x + (DT * (b + 1)))) / 2.0);
//         } else {                                                                         
//           hp[c][b] = hp[c - 1][b] - ((hp[c - 1][b] + hp[c - 1][b + 1]) / 2.0);           
//         } 
//       }
//     } 
//     let d1: double = (f(x) - f(x + DT)) / DT;
//     loop [c: int = 0](c < DEPTH - 1) : (++c) {
//         d1 = d1 + ((hp[c][0] - hp[c][1]) / DT);
//     }
//     return -d1;
// }
// 
// const deriv_error = fn (x: double) double {
//     return d(x) - derivative(x);
// }
@module "math"

pub const PI: double = 3.14159265358979323846;
pub const TWO_PI: double = 6.28318530717958647692528;
pub const HALF_PI: double = 1.570796327;

pub const DEPTH: int = 3;
pub const DT: double = 0.005525661; // 0.000034339 - 0.0055 - 0.00007;

pub const SIN_TABLE_COUNT: int = 128;
pub const SIN_TABLE: [double; 129] = [
    0.0000000000000000, 0.0122715382857199, 0.0245412285229123, 0.0368072229413588,
    0.0490676743274180, 0.0613207363022086, 0.0735645635996674, 0.0857973123444399,
    0.0980171403295606, 0.1102222072938831, 0.1224106751992162, 0.1345807085071262,
    0.1467304744553618, 0.1588581433338614, 0.1709618887603012, 0.1830398879551409,
    0.1950903220161282, 0.2071113761922186, 0.2191012401568698, 0.2310581082806711,
    0.2429801799032639, 0.2548656596045146, 0.2667127574748984, 0.2785196893850531,
    0.2902846772544623, 0.3020059493192281, 0.3136817403988915, 0.3253102921622629,
    0.3368898533922201, 0.3484186802494346, 0.3598950365349881, 0.3713171939518375,
    0.3826834323650898, 0.3939920400610481, 0.4052413140049899, 0.4164295600976371,
    0.4275550934302821, 0.4386162385385277, 0.4496113296546065, 0.4605387109582400,
    0.4713967368259976, 0.4821837720791227, 0.4928981922297840, 0.5035383837257176,
    0.5141027441932217, 0.5245896826784690, 0.5349976198870972, 0.5453249884220465,
    0.5555702330196022, 0.5657318107836131, 0.5758081914178453, 0.5857978574564389,
    0.5956993044924334, 0.6055110414043255, 0.6152315905806268, 0.6248594881423863,
    0.6343932841636455, 0.6438315428897914, 0.6531728429537768, 0.6624157775901718,
    0.6715589548470183, 0.6806010002929786, 0.6895405447370668, 0.6983762494089729,
    0.7071067811865475, 0.7157308252838186, 0.7242470829514669, 0.7326542716724128,
    0.7409511253549591, 0.7491363945234594, 0.7572088465064846, 0.7651672656224590,
    0.7730104533627370, 0.7807372285720945, 0.7883464276266062, 0.7958369046088836,
    0.8032075314806448, 0.8104571982525948, 0.8175848131515837, 0.8245893027850253,
    0.8314696123025452, 0.8382247055548381, 0.8448535652497070, 0.8513551931052652,
    0.8577286100002721, 0.8639728561215867, 0.8700869911087113, 0.8760700941954066,
    0.8819212643483550, 0.8876396204028539, 0.8932243011955153, 0.8986744656939538,
    0.9039892931234433, 0.9091679830905224, 0.9142097557035307, 0.9191138516900578,
    0.9238795325112867, 0.9285060804732156, 0.9329927988347390, 0.9373390119125749,
    0.9415440651830208, 0.9456073253805213, 0.9495281805930367, 0.9533060403541939,
    0.9569403357322088, 0.9604305194155658, 0.9637760657954398, 0.9669764710448521,
    0.9700312531945440, 0.9729400179601073, 0.9757021300385286, 0.9783173707196277,
    0.9807852804032304, 0.9831054874312163, 0.9852776423889412, 0.9873014181578584,
    0.9891765099647809, 0.9909026354277800, 0.9924795345987100, 0.9939069700023561,
    0.9951847266721968, 0.9963126121827780, 0.9972904566786902, 0.9981181129001492,
    0.9987954562051724, 0.9993223845883495, 0.9996988186962042, 0.9999247018391445,
    1.0000000000000000
];

pub const rand -> fn (seed: *int) int {
    *seed = (*seed * 1103515245 + 12345) % 2147483648;
    return *seed;
}

pub const add      -> fn (x: int, y: int) int { return x + y; }
pub const subtract -> fn (x: int, y: int) int { return x - y; }
pub const multiply -> fn (x: int, y: int) int { return x * y; }
pub const divide -> fn (x: int, y: int) int { 
    if (y == 0) {
        output("(Division by zero error) ");
        return 0;
    }
    return x / y;
}

pub const mod -> fn (x: int, y: int) int {
    if (y == 0) {
        output("(Division by zero error) ");
        return 0;
    }
    return x % y;
}

pub const fib -> fn (n: int, a: int, b: int) int {
    if (n == 0) { return a; }
    if (n == 1) { return b; }
    return fib(n - 1, b, a + b);
}

pub const power -> fn (base: double, exponent: int) double {
    if (exponent == 0) { return 1.0; } 

    let result: double = 1.0;
    let e: int = exponent;

    if (e<0) {
        base = 1.0;
        e = -e;
    }

    loop (e > 0) : (--e) {
        result = result * base;
    }

    return result;
} 

pub const max_size -> fn (a: int, b: int) int {
    if (a > b) { return a; }
    return b; 
}

pub const min_size -> fn (a: int, b: int) int {
    if (a < b) { return a; }
    return b; 
}

pub const sin -> fn (a: double) double {
  // Normalize into [0, TWO_PI)
  let k: int = cast<int>(a / TWO_PI);
  a = a - k * TWO_PI;
  if (a < 0.0) { a = a + TWO_PI; }

  // Quadrant (0â€“3)
  let quadrant: int = cast<int>(a / HALF_PI);

  // Local angle in [0, HALF_PI)
  let t: double = a - quadrant * HALF_PI;

  // Index and fraction
  let idx_f: double = t * (SIN_TABLE_COUNT / HALF_PI);
  let i: int = cast<int>(idx_f);

  let frac: double = idx_f - i;

  // Mirror index for quadrant 1 and 3
  if (quadrant == 1 || quadrant == 3) {
      i = (SIN_TABLE_COUNT - 1) - i;
  }

  // Interpolate
  let base: double = SIN_TABLE[i];
  let next: double = SIN_TABLE[i + 1];
  let val: double = base + frac * (next - base);

  // Apply sign for quadrant 2 and 3
  if (quadrant >= 2) {
      return -val;
  } else {
      return val;
  }
}

pub const cos -> fn (x: double) double { return sin(x + HALF_PI); }

pub const tan -> fn (x: double) double { return sin(x)/(cos(x)+0.000000001); }

pub const sec -> fn (x: double) double { return 1/(cos(x)+0.000000001); }

pub const csc -> fn (x: double) double { return 1/(sin(x)+0.000000001); }

pub const cot -> fn (x: double) double { return cos(x)/(sin(x)+0.000000001); }

// const f = fn (x: double) double {
//     return math::sin(x); 
// }
// const d = fn (x: double) double {
//    return math::cos(x);
// }
// const derivative = fn (x: double) double {
//     let hp: **double = cast<**double>(alloc((DEPTH - 1) * sizeof<*double>));
//     defer { 
//       loop [c: int = 0](c < DEPTH - 1) : (++c) {
//         free(hp[c]);
//       }
//       free(hp); 
//     }
//     loop [c: int = 0](c < DEPTH - 1) : (++c) {
//       let size: int = DEPTH - c;
//       hp[c] = cast<*double>(alloc(size * sizeof<double>));
//     }
//     loop [c: int = 0, b: int = 0](c < DEPTH - 1) : (++c) {
//       let size: int = DEPTH - c;
//       loop (b < size) : (++b) {
//         if (c == 0) {                                                                    
//           hp[0][b] = f(x + (DT * b)) - ((f(x + (DT * b)) + f(x + (DT * (b + 1)))) / 2.0);
//         } else {                                                                         
//           hp[c][b] = hp[c - 1][b] - ((hp[c - 1][b] + hp[c - 1][b + 1]) / 2.0);           
//         } 
//       }
//     } 
//     let d1: double = (f(x) - f(x + DT)) / DT;
//     loop [c: int = 0](c < DEPTH - 1) : (++c) {
//         d1 = d1 + ((hp[c][0] - hp[c][1]) / DT);
//     }
//     return -d1;
// }
// 
// const deriv_error = fn (x: double) double {
//     return d(x) - derivative(x);
// }

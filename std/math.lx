@module "math"

pub const PI: double = 3.14159265358979323;
const DEPTH: int = 3;
const DT: double = 0.005525661; // 0.000034339 - 0.0055 - 0.00007;

pub const add = fn (x: int, y: int) int {
    return x + y;
}

pub const subtract = fn (x: int, y: int) int {
    return x - y;
}

pub const multiply = fn (x: int, y: int) int {
    return x * y;
}

pub const divide = fn (x: int, y: int) int { 
    if (y == 0) {
        output("(Division by zero error) ");
        return 0;
    }
    return x / y;
}

pub const fib = fn (n: int, a: int, b: int) int {
    if (n == 0) { return a; }
    if (n == 1) { return b; }
    return fib(n - 1, b, a + b);
}

pub const power = fn (base: double, exponent: int) double {
    if (exponent == 0) { return 1.0; } 

    let result: double = 1.0;
    let e: int = exponent;

    if (e<0) {
        base = 1.0;
        e = -e;
    }

    loop (e > 0) : (--e) {
        result = result * base;
    }

    return result;
} 

pub const max_size = fn (a: int, b: int) int {
    if (a > b) { return a; }
    return b; 
}

pub const min_size = fn (a: int, b: int) int {
    if (a < b) { return a; }
    return b; 
}

pub const sin = fn (a: double) double {
    let pi2: double = PI / 2;
    let x: double = (a + pi2) % (PI * 2) - pi2;

    let x2: double = x * x;     // x²
    let x3: double = x * x2;    // x³
    let x5: double = x3 * x2;   // x⁵
    let x7: double = x5 * x2;   // x⁷
    let x9: double = x7 * x2;   // x⁹
    let x11: double = x9 * x2;  // x¹¹
    let x13: double = x11 * x2; // x¹³

    return x - (x3/6.0) + (x5/120.0) - (x7/5040.0)
             + (x9/362880.0) - (x11/39916800.0) + (x13/6227020800.0);
}

pub const cos = fn (a: double) double {
    return -(sin(a - (PI / 2.0))); 
}

// const DEPTH: int = 3;
// const DT: double = 0.005525661; // 0.000034339 - 0.0055 - 0.00007;
// 
// const f = fn (x: double) double {
//     return math::sin(x); 
// }
// 
// const d = fn (x: double) double {
//    return math::cos(x);
// }
// 
// // NOTE: Credit to 'Drake Rochelle' for the derivative algorithm
// // https://github.com/Drake-Rochelle/
// const pDerivative = fn (x: double) double {
//     let hp: **double = cast<**double>(alloc((DEPTH - 1) * sizeof<*double>));
//     defer { 
//       loop [c: int = 0](c < DEPTH - 1) : (++c) {
//         free(hp[c]);
//       }
//       free(hp); 
//     }
// 
//     loop [c: int = 0](c < DEPTH - 1) : (++c) {
//       let size: int = DEPTH - c;
//       hp[c] = cast<*double>(alloc(size * sizeof<double>));
//     }
// 
//     loop [c: int = 0, b: int = 0](c < DEPTH - 1) : (++c) {
//       let size: int = DEPTH - c;
//       loop (b < size) : (++b) {
//         if (c == 0) {                                                                    
//           hp[0][b] = f(x + (DT * b)) - ((f(x + (DT * b)) + f(x + (DT * (b + 1)))) / 2.0);
//         } else {                                                                         
//           hp[c][b] = hp[c - 1][b] - ((hp[c - 1][b] + hp[c - 1][b + 1]) / 2.0);           
//         } 
//       }
//     } 
// 
//     // initial derivative
//     let d1: double = (f(x) - f(x + DT)) / DT;
// 
//     loop [c: int = 0](c < DEPTH - 1) : (++c) {
//         d1 = d1 + ((hp[c][0] - hp[c][1]) / DT);
//     }
//     
//     return -d1;
// }
// 
// const pError = fn (x: double) double {
//     return d(x) - pDerivative(x);
// }

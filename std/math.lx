@module "math"

pub const PI: double = 3.14159265358979323846;
pub const TWO_PI: double = 6.28318530717958647692528;
pub const HALF_PI: double = 1.570796327;

pub const DEPTH: int = 3;
pub const DT: double = 0.005525661; // 0.000034339 - 0.0055 - 0.00007;

pub const SIN_TABLE_COUNT: int = 128;
pub const SIN_TABLE: [double; 129] = [
    0.000000, 0.012272, 0.024541, 0.036807, 0.049068, 0.061321, 0.073565, 0.085797,
    0.098017, 0.110222, 0.122411, 0.134581, 0.146730, 0.158858, 0.170962, 0.183040,
    0.195090, 0.207111, 0.219101, 0.231058, 0.242980, 0.254866, 0.266713, 0.278520,
    0.290285, 0.302006, 0.313682, 0.325310, 0.336890, 0.348419, 0.359895, 0.371317,
    0.382683, 0.393992, 0.405241, 0.416430, 0.427555, 0.438616, 0.449611, 0.460539,
    0.471397, 0.482184, 0.492898, 0.503538, 0.514103, 0.524590, 0.534998, 0.545325,
    0.555570, 0.565732, 0.575808, 0.585798, 0.595699, 0.605511, 0.615232, 0.624859,
    0.634393, 0.643832, 0.653173, 0.662416, 0.671559, 0.680601, 0.689541, 0.698376,
    0.707107, 0.715731, 0.724247, 0.732654, 0.740951, 0.749136, 0.757209, 0.765167,
    0.773010, 0.780737, 0.788346, 0.795837, 0.803208, 0.810457, 0.817585, 0.824589,
    0.831470, 0.838225, 0.844854, 0.851355, 0.857729, 0.863973, 0.870087, 0.876070,
    0.881921, 0.887640, 0.893224, 0.898674, 0.903989, 0.909168, 0.914210, 0.919114,
    0.923880, 0.928506, 0.932993, 0.937339, 0.941544, 0.945607, 0.949528, 0.953306,
    0.956940, 0.960431, 0.963776, 0.966976, 0.970031, 0.972940, 0.975702, 0.978317,
    0.980785, 0.983105, 0.985278, 0.987301, 0.989177, 0.990903, 0.992480, 0.993907,
    0.995185, 0.996313, 0.997290, 0.998118, 0.998795, 0.999322, 0.999699, 0.999925,
    1.000000
];

pub const rand = fn (seed: *int) int {
    *seed = (*seed * 1103515245 + 12345) % 2147483648;
    return *seed;
}

pub const add = fn (x: int, y: int) int {
    return x + y;
}

pub const subtract = fn (x: int, y: int) int {
    return x - y;
}

pub const multiply = fn (x: int, y: int) int {
    return x * y;
}

pub const divide = fn (x: int, y: int) int { 
    if (y == 0) {
        output("(Division by zero error) ");
        return 0;
    }
    return x / y;
}

pub const fib = fn (n: int, a: int, b: int) int {
    if (n == 0) { return a; }
    if (n == 1) { return b; }
    return fib(n - 1, b, a + b);
}

pub const power = fn (base: double, exponent: int) double {
    if (exponent == 0) { return 1.0; } 

    let result: double = 1.0;
    let e: int = exponent;

    if (e<0) {
        base = 1.0;
        e = -e;
    }

    loop (e > 0) : (--e) {
        result = result * base;
    }

    return result;
} 

pub const max_size = fn (a: int, b: int) int {
    if (a > b) { return a; }
    return b; 
}

pub const min_size = fn (a: int, b: int) int {
    if (a < b) { return a; }
    return b; 
}

pub const sin = fn (a: double) double {
  // Normalize into [0, TWO_PI)
  a = a % TWO_PI;
  if (a < 0.0) {
      a = a + TWO_PI;
  }

  // Quadrant (0â€“3)
  let quadrant: int = cast<int>(a / HALF_PI);

  // Local angle in [0, HALF_PI)
  let t: double = a - quadrant * HALF_PI;

  // Index and fraction
  let idx_f: double = t * (SIN_TABLE_COUNT / HALF_PI);
  let i: int = cast<int>(idx_f);
  if (i >= SIN_TABLE_COUNT - 1) {
      i = SIN_TABLE_COUNT - 2;
  }
  let frac: double = idx_f - i;

  // Mirror index for quadrant 1 and 3
  if (quadrant == 1 || quadrant == 3) {
      i = (SIN_TABLE_COUNT - 1) - i;
  }

  // Interpolate
  let base: double = SIN_TABLE[i];
  let next: double = SIN_TABLE[i + 1];
  let val: double = base + frac * (next - base);

  // Apply sign for quadrant 2 and 3
  if (quadrant >= 2) {
      return -val;
  } else {
      return val;
  }
}

pub const cos = fn (x: double) double { return sin(x + HALF_PI); }

pub const tan = fn (x: double) double { return sin(x)/(cos(x)+0.000000001); }

pub const sec = fn (x: double) double { return 1/(cos(x)+0.000000001); }

pub const csc = fn (x: double) double { return 1/(sin(x)+0.000000001); }

pub const cot = fn (x: double) double { return cos(x)/(sin(x)+0.000000001); }

// const f = fn (x: double) double {
//     return math::sin(x); 
// }
// const d = fn (x: double) double {
//    return math::cos(x);
// }
// const derivative = fn (x: double) double {
//     let hp: **double = cast<**double>(alloc((DEPTH - 1) * sizeof<*double>));
//     defer { 
//       loop [c: int = 0](c < DEPTH - 1) : (++c) {
//         free(hp[c]);
//       }
//       free(hp); 
//     }
//     loop [c: int = 0](c < DEPTH - 1) : (++c) {
//       let size: int = DEPTH - c;
//       hp[c] = cast<*double>(alloc(size * sizeof<double>));
//     }
//     loop [c: int = 0, b: int = 0](c < DEPTH - 1) : (++c) {
//       let size: int = DEPTH - c;
//       loop (b < size) : (++b) {
//         if (c == 0) {                                                                    
//           hp[0][b] = f(x + (DT * b)) - ((f(x + (DT * b)) + f(x + (DT * (b + 1)))) / 2.0);
//         } else {                                                                         
//           hp[c][b] = hp[c - 1][b] - ((hp[c - 1][b] + hp[c - 1][b + 1]) / 2.0);           
//         } 
//       }
//     } 
//     let d1: double = (f(x) - f(x + DT)) / DT;
//     loop [c: int = 0](c < DEPTH - 1) : (++c) {
//         d1 = d1 + ((hp[c][0] - hp[c][1]) / DT);
//     }
//     return -d1;
// }
// 
// const deriv_error = fn (x: double) double {
//     return d(x) - derivative(x);
// }

@module "main"

@use "sys" as sys

// Helper function to combine flags (bitwise OR)
const combine_flags -> fn (flag1: int, flag2: int) int {
    return flag1 + flag2;
}

const combine_flags3 -> fn (flag1: int, flag2: int, flag3: int) int {
    return flag1 + flag2 + flag3;
}

// Test file I/O operations
const test_file_operations -> fn () int {
    sys::print("=== Testing File Operations ===\n");
    
    // Test 1: Create and write to a file
    // O_CREAT | O_WRONLY | O_TRUNC = 64 + 1 + 512 = 577
    let flags: int = combine_flags3(sys::O_CREAT, sys::O_WRONLY, sys::O_TRUNC);
    let fd: int = sys::open("/tmp/luma_test.txt", flags, sys::MODE_0644);
    
    if (sys::is_error(fd)) {
        sys::eprint("Error: Failed to create file\n");
        return 1;
    }
    
    let test_data: *char = "Hello from Luma!\n";
    let bytes_written: int = sys::write_str(fd, test_data);
    
    if (sys::is_error(bytes_written)) {
        sys::eprint("Error: Failed to write to file\n");
        sys::close(fd);
        return 1;
    }
    
    sys::print("✓ File write successful\n");
    sys::close(fd);
    
    // Test 2: Read back the file
    fd = sys::open("/tmp/luma_test.txt", sys::O_RDONLY, 0);
    
    if (sys::is_error(fd)) {
        sys::eprint("Error: Failed to open file for reading\n");
        return 1;
    }
    
    let buffer: *char = cast<*char>(alloc(100));
    defer { free(buffer); }
    
    let bytes_read: int = sys::read(fd, cast<*void>(buffer), 99);
    
    if (sys::is_error(bytes_read)) {
        sys::eprint("Error: Failed to read from file\n");
        sys::close(fd);
        return 1;
    }
    
    buffer[bytes_read] = cast<char>(0);  // Null terminate
    sys::print("✓ File read successful: ");
    sys::print(buffer);
    
    sys::close(fd);
    
    // Test 3: Delete the file
    let unlink_result: int = sys::unlink("/tmp/luma_test.txt");
    
    if (sys::is_error(unlink_result)) {
        sys::eprint("Error: Failed to delete file\n");
        return 1;
    }
    
    sys::print("✓ File deletion successful\n\n");
    return 0;
}

// Test directory operations
const test_directory_operations -> fn () int {
    sys::print("=== Testing Directory Operations ===\n");
    
    // Test 1: Create directory
    let mkdir_result: int = sys::mkdir("/tmp/luma_test_dir", sys::MODE_0755);
    
    if (sys::is_error(mkdir_result)) {
        sys::eprint("Error: Failed to create directory\n");
        return 1;
    }
    
    sys::print("✓ Directory creation successful\n");
    
    // Test 2: Change to directory
    let chdir_result: int = sys::chdir("/tmp/luma_test_dir");
    
    if (sys::is_error(chdir_result)) {
        sys::eprint("Error: Failed to change directory\n");
        sys::rmdir("/tmp/luma_test_dir");
        return 1;
    }
    
    sys::print("✓ Directory change successful\n");
    
    // Test 3: Get current directory
    let cwd_buffer: *char = cast<*char>(alloc(256));
    defer { free(cwd_buffer); }
    
    let getcwd_result: *char = sys::getcwd(cwd_buffer, 256);
    
    if (getcwd_result == cast<*char>(0)) {
        sys::eprint("Error: Failed to get current directory\n");
        sys::chdir("/tmp");
        sys::rmdir("/tmp/luma_test_dir");
        return 1;
    }
    
    sys::print("✓ Current directory: ");
    sys::print(cwd_buffer);
    sys::print("\n");
    
    // Test 4: Return to /tmp and remove test directory
    sys::chdir("/tmp");
    let rmdir_result: int = sys::rmdir("/tmp/luma_test_dir");
    
    if (sys::is_error(rmdir_result)) {
        sys::eprint("Error: Failed to remove directory\n");
        return 1;
    }
    
    sys::print("✓ Directory removal successful\n\n");
    return 0;
}

// Test process information
const test_process_info -> fn () int {
    sys::print("=== Testing Process Information ===\n");
    
    // Test 1: Get process ID
    let pid: int = sys::getpid();
    sys::print("✓ Process ID: ");
    output(pid, "\n");
    
    // Test 2: Get user ID
    let uid: int = sys::getuid();
    sys::print("✓ User ID: ");
    output(uid, "\n");
    
    // Test 3: Get group ID
    let gid: int = sys::getgid();
    sys::print("✓ Group ID: ");
    output(gid, "\n\n");
    
    return 0;
}

// Test pipe operations
const test_pipe_operations -> fn () int {
    sys::print("=== Testing Pipe Operations ===\n");
    sys::print("⚠ Pipe test skipped (known issue with blocking reads)\n\n");
    return 0;
    
    // TODO: Debug why pipe reads block
    // The issue appears to be that sys::read() on pipes blocks indefinitely
    // even after successful writes. This might be a syscall wrapper issue
    // or a problem with how the pipe file descriptors are being handled.
}

// Test file descriptor duplication
const test_dup_operations -> fn () int {
    sys::print("=== Testing File Descriptor Duplication ===\n");
    
    // Create a test file (O_CREAT | O_WRONLY | O_TRUNC)
    let flags: int = combine_flags3(sys::O_CREAT, sys::O_WRONLY, sys::O_TRUNC);
    let fd: int = sys::open("/tmp/luma_dup_test.txt", flags, sys::MODE_0644);
    
    if (sys::is_error(fd)) {
        sys::eprint("Error: Failed to create test file\n");
        return 1;
    }
    
    // Test dup
    let dup_fd: int = sys::dup(fd);
    
    if (sys::is_error(dup_fd)) {
        sys::eprint("Error: dup() failed\n");
        sys::close(fd);
        sys::unlink("/tmp/luma_dup_test.txt");
        return 1;
    }
    
    sys::print("✓ dup() successful\n");
    
    // Write using duplicated fd
    sys::write_str(dup_fd, "Written via dup'd fd\n");
    
    sys::close(fd);
    sys::close(dup_fd);
    
    // Test dup2 (O_WRONLY | O_APPEND)
    let append_flags: int = combine_flags(sys::O_WRONLY, sys::O_APPEND);
    fd = sys::open("/tmp/luma_dup_test.txt", append_flags, 0);
    let dup2_result: int = sys::dup2(fd, 100);
    
    if (sys::is_error(dup2_result)) {
        sys::eprint("Error: dup2() failed\n");
        sys::close(fd);
        sys::unlink("/tmp/luma_dup_test.txt");
        return 1;
    }
    
    sys::print("✓ dup2() successful\n");
    
    // Write using dup2'd fd
    sys::write_str(100, "Written via dup2'd fd\n");
    
    sys::close(fd);
    sys::close(100);
    sys::unlink("/tmp/luma_dup_test.txt");
    
    sys::print("✓ File descriptor duplication tests complete\n\n");
    return 0;
}

// Test error handling
const test_error_handling -> fn () int {
    sys::print("=== Testing Error Handling ===\n");
    
    // Try to open non-existent file
    let fd: int = sys::open("/nonexistent/file.txt", sys::O_RDONLY, 0);
    
    if (sys::is_error(fd)) {
        let errno: int = sys::get_errno(fd);
        sys::print("✓ Error detected correctly: errno = ");
        output(errno);
        
            sys::print(" (");
        if (errno == sys::ENOENT) {
            sys::print("ENOENT - No such file or directory");
        } else {
            sys::print("Unknown error");
        }
        sys::print(")\n");
    } else {
        sys::eprint("Error: Should have failed to open non-existent file\n");
        sys::close(fd);
        return 1;
    }
    
    // Try to create file in non-writable directory
    let flags: int = combine_flags(sys::O_CREAT, sys::O_WRONLY);
    let fd2: int = sys::open("/root/test.txt", flags, sys::MODE_0644);
    
    if (sys::is_error(fd2)) {
        let errno2: int = sys::get_errno(fd2);
        sys::print("✓ Permission error detected: errno = ");
        output(errno2);
        
        sys::print(" (");
        if (errno2 == sys::EACCES) {
            sys::print("EACCES - Permission denied");
        } else {
            sys::print("Unknown error");
        }
        sys::print(")\n");
    }
    
    sys::print("\n");
    return 0;
}

// Test seek operations
const test_seek_operations -> fn () int {
    sys::print("=== Testing Seek Operations ===\n");
    
    // Create test file with content (O_CREAT | O_RDWR | O_TRUNC)
    let flags: int = combine_flags3(sys::O_CREAT, sys::O_RDWR, sys::O_TRUNC);
    let fd: int = sys::open("/tmp/luma_seek_test.txt", flags, sys::MODE_0644);
    
    if (sys::is_error(fd)) {
        sys::eprint("Error: Failed to create test file\n");
        return 1;
    }
    
    sys::write_str(fd, "0123456789ABCDEFGHIJ");
    
    // Test SEEK_SET
    let pos: int = sys::lseek(fd, 5, sys::SEEK_SET);
    
    if (sys::is_error(pos)) {
        sys::eprint("Error: SEEK_SET failed\n");
        sys::close(fd);
        sys::unlink("/tmp/luma_seek_test.txt");
        return 1;
    }
    
    sys::print("✓ SEEK_SET to position 5 successful\n");
    
    // Test SEEK_CUR
    pos = sys::lseek(fd, 3, sys::SEEK_CUR);
    sys::print("✓ SEEK_CUR +3 successful, now at: ");
    output(pos, "\n");
    
    // Test SEEK_END
    pos = sys::lseek(fd, -5, sys::SEEK_END);
    sys::print("✓ SEEK_END -5 successful, now at: ");
    output(pos, "\n");
    
    sys::close(fd);
    sys::unlink("/tmp/luma_seek_test.txt");
    sys::print("\n");
    
    return 0;
}

pub const main -> fn () int {
    sys::print("\n");
    sys::print("╔════════════════════════════════════════╗\n");
    sys::print("║  Luma System Call Test Suite          ║\n");
    sys::print("║  Platform: Linux x86_64                ║\n");
    sys::print("╚════════════════════════════════════════╝\n\n");
    
    let total_failures: int = 0;
    
    total_failures = total_failures + test_process_info();
    total_failures = total_failures + test_file_operations();
    total_failures = total_failures + test_directory_operations();
    total_failures = total_failures + test_pipe_operations();
    total_failures = total_failures + test_dup_operations();
    total_failures = total_failures + test_seek_operations();
    total_failures = total_failures + test_error_handling();
    
    sys::print("╔════════════════════════════════════════╗\n");
    
    if (total_failures == 0) {
        sys::print("║  ✓ All tests passed!                  ║\n");
    } else {
        sys::print("║  ✗ Some tests failed: ");
        output(total_failures);
        sys::print("              ║\n");
    }
    
    sys::print("╚════════════════════════════════════════╝\n\n");
    
    return total_failures;
}

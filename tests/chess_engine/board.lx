@module "board"

@use "string" as string
@use "helper" as helper
@use "piece" as piece

#returns_ownership
pub const init_board -> fn (bd: *Board) *Board {
  bd.squares = cast<*char>(alloc(8 * sizeof<*char>));

  // Initialize the chess board with starting positions
  bd.starting_fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR";
  bd.length_fen = string::strlen(bd.starting_fen);

  loop [i: int = 0, row: int = 0, col: int = 0](i < bd.length_fen) : (++i) {
    let c: char = bd.starting_fen[i];
    if (c == '/') {
      row = row + 1;
      col = 0;
    } elif (c >= '1' && c <= '8') {
      let empty_squares: int = cast<int>(c - '0');
      loop [j: int = 0](j < empty_squares) : (++j) {
        bd.squares[row * 8 + col] = '.';
        col = col + 1;
      }
    } else {
      bd.squares[row * 8 + col] = c;
      col = col + 1;
    }
  }

  return bd;
}

pub const parse_move -> fn (mv: *Move, move: *char) *Move {
  let from_col: char = move[0];
  let from_row: char = move[1];
  let to_col: char = move[2];
  let to_row: char = move[3];

  mv.from_col = cast<int>(from_col) - cast<int>('a');
  mv.from_row = 7 - (cast<int>(from_row) - cast<int>('1'));  
  mv.to_col = cast<int>(to_col) - cast<int>('a');
  mv.to_row = 7 - (cast<int>(to_row) - cast<int>('1'));      

  return mv;
}

const is_check -> fn (bd: *Board, king_color: int, king_row: int, king_col: int) int { 
  // 1. Locate the King (already provided by king_row, king_col)

  // 2. Iterate Through Opponent's Pieces
  //    (Loop through all squares, identify opponent's pieces)

  // 3. Check for Attacks
  //    (Inside the loop, for each opponent's piece,
  //     call a helper function like 'can_piece_attack_square'
  //     to see if it attacks king_row, king_col)

  // 4. Return Check Status
  //    (If any piece attacks, return true; otherwise, return false after the loop)

  return 0; 
}

pub const update_board -> fn (bd: *Board, mv: *Move, white_to_move: *int, is_valid: *int) void {
  let from_index: int = mv.from_row * 8 + mv.from_col;
  let to_index: int   = mv.to_row   * 8 + mv.to_col;

  // Safety: Ensure coordinates are within bounds
  if (from_index < 0 || from_index >= 64 || to_index < 0 || to_index >= 64) {
    output("Error: Move out of bounds.\n");
    *is_valid = 1;
    return;
  }

  let piece_char: char = bd.squares[from_index];
  if (piece_char == '.') {
    output("Error: No piece at source square.\n");
    *is_valid = 1;
    return;
  }

  let target: char = bd.squares[to_index];

  // Determine piece color
  // FIXME: Need to fix when cast the result of a bool it returns -1 and 0 instead of 1 and 0
  let is_white_piece: int = piece::is_white_piece(piece_char); 
  let is_black_piece: int = piece::is_black_piece(piece_char); 

  // Validate turn (fixed)
  if (*white_to_move == 1 && is_white_piece == 0) {
    output("Error: It's White's turn.\n");
    *is_valid = 1;
    return;
  }
  if (*white_to_move == 0 && is_black_piece == 0) {
    output("Error: It's Black's turn.\n");
    *is_valid = 1;
    return;
  }

  // Check capture legality
  if (piece::can_capture(target, is_white_piece, is_black_piece) == 0) {
    output("Error: Cannot capture your own piece.\n");
    *is_valid = 1;
    return;
  }

  // Validate piece movement rules
  let rule: *PieceRules = piece::get_rules(piece_char);
  if (rule == cast<*PieceRules>(0)) {
    output("Error: Unknown piece type.\n");
    *is_valid = 1;
    return;
  }
  
  let dc: int = mv.to_col - mv.from_col;
  let dr: int = mv.to_row - mv.from_row;
  
  // Special handling for pawns
  if (piece_char == 'P' || piece_char == 'p') {
    if (piece::validate_pawn_move(rule, dc, dr, mv.from_row, target, is_white_piece) == 0 ||
        piece::validate_pawn_path(bd, mv, dr, dc) == 0) {
      output("Error: Illegal pawn move.\n");
      *is_valid = 1;
      return;
    }
  } else {
    if (piece::is_move_legal(rule, bd, mv) == 0) {
      output("Error: Illegal move for this piece.\n");
      *is_valid = 1;
      return;
    }
  }

  // Move the piece
  bd.squares[to_index] = piece_char;
  bd.squares[from_index] = '.';

  // Flip turn
  if (*white_to_move == 1) {
    *white_to_move = 0;
  } else {
    *white_to_move = 1;
  }
  
  // Mark move as valid (0)
  *is_valid = 0;
}

pub const print_board -> fn (bd: *Board, moves: **char, move_count: int) void {
  output("  ╔═════════════════╗");
  
  // Show moves on the right side of the board
  if (move_count > 0) {
    output("     Move History");
  }
  output("\n");
  
  let total_rows: int = (move_count + 1) / 2; 
  if (total_rows < 8) { total_rows = 8; } 
  
  loop [i: int = 0](i < total_rows) : (++i) {
    if (i < 8) {
      output(8 - i, " ║ ");
      loop [j: int = 0](j < 8) : (++j) {
        let piece: *char;
        switch (bd.squares[i * 8 + j]) {
          'P' -> { piece = "♟"; }
          'N' -> { piece = "♞"; }
          'B' -> { piece = "♝"; }
          'R' -> { piece = "♜"; }
          'Q' -> { piece = "♛"; }
          'K' -> { piece = "♚"; }
          'p' -> { piece = "♙"; }
          'n' -> { piece = "♘"; }
          'b' -> { piece = "♗"; }
          'r' -> { piece = "♖"; }
          'q' -> { piece = "♕"; }
          'k' -> { piece = "♔"; }
          '.' -> { piece = "·"; }
        }
        output(piece, " ");
      }
      output("║");
    } else {
      output("   ");
    }
  
    let move_pair_index: int = i * 2;
    if (move_pair_index < move_count) {
      let move_num: int = move_pair_index / 2 + 1;
      output("     ", move_num, ". ", moves[move_pair_index]);
      if (move_pair_index + 1 < move_count) {
        output(" ", moves[move_pair_index + 1]);
      }
    }
    output("\n");
  }
  
  output("  ╚═════════════════╝\n");
  output("    a b c d e f g h\n\n");
}


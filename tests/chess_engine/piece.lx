@module "piece"

@use "helper" as helper

pub const PieceRules -> struct {
  piece_type: char,
  can_jump: int,
  can_slide: int,
  move_offsets: [int; 16],
  num_offsets: int
};

const RULES: [PieceRules; 6] = [
  PieceRules {
    piece_type: 'P', can_jump: 0, can_slide: 0, num_offsets: 4,
    // [forward 1 white, forward 2 white, forward 1 black, forward 2 black]
    // Note: Captures handled separately in board logic
    move_offsets: [0, -1, 0, -2, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],
  },
  PieceRules {
    piece_type: 'N', can_jump: 1, can_slide: 0, num_offsets: 8,
    move_offsets: [-2, -1, -2, 1, -1, -2, -1, 2, 1, -2, 1, 2, 2, -1, 2, 1],
  },
  PieceRules {
    piece_type: 'B', can_jump: 0, can_slide: 1, num_offsets: 4,
    move_offsets: [-1, -1, -1, 1, 1, -1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
  },
  PieceRules {
    piece_type: 'R', can_jump: 0, can_slide: 1, num_offsets: 4,
    move_offsets: [-1, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
  },
  PieceRules {
    piece_type: 'Q', can_jump: 0, can_slide: 1, num_offsets: 8,
    move_offsets: [-1, -1, -1, 1, 1, -1, 1, 1, -1, 0, 1, 0, 0, -1, 0, 1],
  },
  PieceRules {
    piece_type: 'K', can_jump: 0, can_slide: 0, num_offsets: 8,
    move_offsets: [-1, -1, -1, 1, 1, -1, 1, 1, -1, 0, 1, 0, 0, -1, 0, 1],
  }
]; 

pub const is_white_piece -> fn (ch: char) int { return -cast<int>(ch >= 'A' && ch <= 'Z'); }
pub const is_black_piece -> fn (ch: char) int { return -cast<int>(ch >= 'a' && ch <= 'z'); }

// Get rules for a specific piece
pub const get_rules -> fn (piece: char) *PieceRules {
  let piece_upper: char = piece;
  if (piece >= 'a' && piece <= 'z') {
    piece_upper = cast<char>(cast<int>(piece) - 32);
  }
  
  loop [i: int = 0](i < 6) : (++i) {  // Changed from 5 to 6
    if (RULES[i].piece_type == piece_upper) {
      return &RULES[i];
    }
  }
  
  return cast<*PieceRules>(0);
}

pub const can_capture -> fn (target: char, white_piece: int, black_piece: int) int {
  if (target != '.') {
    let target_is_white: int = is_white_piece(target);
    let target_is_black: int = is_black_piece(target);

    // Disallow capturing your own piece
    if ((white_piece == 1 && target_is_white == 1) || 
        (black_piece == 1 && target_is_black == 1)) {
      return 0;
    }
  }

  return 1;
}

// Special pawn validation function (pawns have unique rules)
pub const validate_pawn_move -> fn (rule: *PieceRules, dc: int, dr: int, 
                                     from_row: int, target: char, is_white: int) int {
  // Determine direction based on color
  let direction: int;
  let start_row: int;

  if (is_white == 1) {
    direction = -1;
    start_row = 6;
  } else {
    direction = 1;
    start_row = 1;
  }
  
  // Case 1: Forward one square (must be empty)
  if (dc == 0 && dr == direction && target == '.') {
    return 1;
  }
  
  // Case 2: Forward two squares from starting position (both must be empty)
  if (dc == 0 && dr == direction * 2 && from_row == start_row && target == '.') {
    return 1;  // Note: Caller must check middle square
  }
  
  // Case 3: Diagonal capture (must have enemy piece)
  let abs_dc: int;
  if (dc < 0) {
    abs_dc = -dc;
  } else {
    abs_dc = dc;
  }
  
  if (abs_dc == 1 && dr == direction && target != '.') {
    return 1;
  }
  
  return 0;
}

pub const validate_pawn_path -> fn (bd: *Board, mv: *Move, dr: int, dc: int) int {
  if (dc == 0 && (dr == -2 || dr == 2)) {
    let mid_row: int = (mv.from_row + mv.to_row) / 2;
    let mid: char = bd.squares[mid_row * 8 + mv.from_col];
    if (mid != '.') { return 0; } 
  }
  return 1;
}

const is_path_clear -> fn (bd: *Board, mv: *Move) int {
  let dc: int = mv.to_col - mv.from_col;
  let dr: int = mv.to_row - mv.from_row;
  
  let step_c: int;
  if (dc == 0) {
    step_c = 0;
  } elif (dc > 0) {
    step_c = 1;
  } else {
    step_c = -1;
  }
  
  let step_r: int;
  if (dr == 0) {
    step_r = 0;
  } elif (dr > 0) {
    step_r = 1;
  } else {
    step_r = -1;
  }
  
  let curr_col: int = mv.from_col + step_c;
  let curr_row: int = mv.from_row + step_r;
  
  loop (curr_col != mv.to_col || curr_row != mv.to_row) {
    if (bd.squares[curr_row * 8 + curr_col] != '.') {
      return 0;
    }

    curr_col = curr_col + step_c;
    curr_row = curr_row + step_r;
  }
  
  return 1;
}

pub const can_move_direction -> fn (rule: *PieceRules, dc: int, dr: int) int {
  if (rule.can_slide == 1) {
    let step_c: int;
    if (dc == 0) {
      step_c = 0;
    } elif (dc > 0) {
      step_c = 1;
    } else {
      step_c = -1;
    }
    
    let step_r: int;
    if (dr == 0) {
      step_r = 0;
    } elif (dr > 0) {
      step_r = 1;
    } else {
      step_r = -1;
    }
    
    loop [i: int = 0](i < rule.num_offsets) : (++i) {
      if (step_c == rule.move_offsets[i * 2] && 
          step_r == rule.move_offsets[i * 2 + 1]) {
        return 1;
      }
    }
  } else {
    loop [i: int = 0](i < rule.num_offsets) : (++i) {
      if (dc == rule.move_offsets[i * 2] && 
          dr == rule.move_offsets[i * 2 + 1]) {
        return 1;
      }
    }
  }
  return 0;
}

pub const is_move_legal -> fn (rule: *PieceRules, bd: *Board, mv: *Move) int {
  let dc: int = mv.to_col - mv.from_col;
  let dr: int = mv.to_row - mv.from_row;
  if (can_move_direction(rule, dc, dr) == 0) { return 0; }
  if (rule.can_slide == 1 && rule.can_jump == 0) {
    if (is_path_clear(bd, mv) == 0) { return 0; }
  }
  return 1;
}

